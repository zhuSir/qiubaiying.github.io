---
layout:     post
title:      对线程复习记录篇
subtitle:   线程记录篇
date:       2019-05-20
author:     Dawu
header-img: img/post_background.png
catalog: true
tags:
    - 线程
---
## **对线程复习记录篇**

这段时间闲置在家，趁此机会复习下自己薄弱点，此篇是记录复习线程知识点；
1、上下文切换
	CPU会通过分配执行片段给每个线程执行，线程切换是会进行保存本次执行的状态以便下次切换回来知道任务执行到哪。所以频繁的切换会影响到多线程的执行速度；
	如何减少上下文切换
	1、无锁并发编程
	多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可用一些方法避免使用锁，如将数据id按照Hash算法取模分段，不同的相册处理不同段的数据；
	2、CAS算法
	3、使用最少的线程
	4、协程
	在单线程里面实现多任务的调度，并在单线程里维持多个任务间的切换；
2、死锁
	一个线程引用另一个线程可能会导致互相等待导致死锁；
	避免死锁的几个常见方法；
	1、避免一个线程同时获取多个锁；
	2、避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源；
	3、尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制；
	4、对于数据库锁，加锁和解锁必须在一个数据库链接里，否则会出现解锁失败的情况；
3、资源限制
	硬件或软件资源上的限制并发多线程执行也不会提高效率；如带宽的上传/下载速度、硬盘读写速度、CPU处理速度，数据库链接数、socket链接数；
4、偏向锁
	当只有一个线程进行同步快的执行时，锁为偏向锁；当出现多个线程竞争同步锁时，释放偏向锁，进行资源的竞争，锁升级为轻量级锁；（适用单线程执行场景）
5、轻量级锁
	线程执行同步快之前会通过CAS设置对象头的锁记录指针，如果设置成功则获取锁并执行同步快；如获取失败这开始自旋获取锁（自旋锁；自旋会消耗CPU资源）；自旋次数默认；如自旋到最大次数还未获取锁线程将进入阻塞变成重量级锁；释放锁时判断如果还有别的线程竞争获取锁，这会膨胀成重量级锁；（适用极少线程竞争，响应时间较短，同步块执行执行速度快；场景）
6、重量级锁
	多线程竞争获取锁时会出现重量级锁；（适用于多线程竞争；吞吐量大，但是同步块自旋速度较长；）
7、原子操作（不可被中断的一个或一系列操作）
	CAS实现原子操作，java并发包中提供了支持原子操作的类；AtomicBoolean、AtomicInteger、AtomicLong;
	CAS实现原子操作的三大问题：
	1、ABA问题:
		cas操作值的时候检测值有没有变化，但是如果一个值原来是A，变成了B，然后又变成了A，那么使用CAS判断就是未发生变化，但实际已经变化了；解决方法：引入版本号判断CAS；JDK中Atomic包中提供了AtomicStampedReference类来解决ABA问题；
	2、循环时间长开销大问题：
		自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销；
	3、只能保证一个共享变量的原子操作问题：
		选好CAS的方法来保证原子操作，单对多个共享遍历操作是，是保证不了原子性的；
8、操作重排序
	重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。
	1、编译器优化重排序
	2、指令级并行重排序
	3、内存系统重排序
	4、执行指令重排序
	不管如何重排序，编译器和处理器会保证单线程执行的结果不被改变。
	对于存在数据依赖性的将不进行重排序。
	如操作不是数据依赖性那将进行重排序，会影响多线程执行结果。
9、内存可见性
	处理器为了执行效率会有自己的高速缓存区用于缓存需要执行的指令。由于处理器之间高速缓存区不可见，所以会导致变量的内存可见性问题，如是多线程执行会导致执行结果不是预期结果。（可通过volatile修饰变量来避免内存可见性问题）
10、处理器上64位变量
	如果程序执行在32位的处理器上那么64位的long/double型变量的写操作将被拆分成两个32位的写操作执行，在jdk5之前会出现读写都拆分成两个32位的读写，将会出现读到写了一半的无效值。当jdk5以上读操作保证必须具有原子性。所以读将不会出现读出无效变量情况。
11、volatile特性
	1、可见性。对于一个volatile变量的读，总是能看到对这个volatile变量最后的写入；
	2、原子性。对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性；
	用volatile修饰的变量不会出现指令重排序（写操作的时候），可以报障不会出现内存可见性问题，实现不加锁报障线程安全。
12、synchronized
	用synchronized关键字修饰的方法或者同步块，他主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，他保证了线程对变量访问的可见性和排他性；
13、线程优先级
	现代操作系统基本采用分时形式调度运行的线程。线程优先级决定了分配的时间片段的多少；可以通过设置线程的priority属性修改优先级；线程默认的优先级是5；（现大多数的系统都会默认忽略优先级设置）
14、线程状态
	1、NEW（初始化状态，线程被构建，但是还没有调用start()方法）
	2、RUNNABLE（运行状态，java线程将操作系统中的就绪和运行两种状态统称为“运行中”）
	3、BOCKED（阻塞状态，表示线程阻塞于锁）
	4、WAITING（等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断））
	5、TIME_WAITING（超时等待状态，该状态不同于WAITING，它是可以在指定的时间自行返回的）
	6、TRMINATED（终止状态，表示当前线程已经执行完毕）
15、Daemon线程
	守护线程，可通过线程的setDaemon(true)属性来将线程设置成守护线程；但jvm中没有非Daemon线程，jvm会退出；
16、线程中断
	设置线程的interrupt()方法对其进行中断操作；线程通过检查自身是否被中断来进行响应，线程通过方法isInterrupted()方法来进行判断是否被中断，也可以调用静态方法Thread.interrupted()方法对方当前线程的中断的标识位进行复位；
17、线程间通信
	线程间通信采用共享变量来进行线程间通信
	1、等待/通知机制（等待/通知的相关方法是任意java对象都具备的，该方法被定义在所有对象的超类java.lang.Object上）
	notify()：通知一个对象上等待的线程，使其从wait()方法返回，返回的前提是该线程获取到对象的锁；
	notifyAll()：通知所有等待在该对象上的线程
	wait()：调用该方法的线程进入WAITING状态，只有等待另外线程的通知或者被中断才会返回，需要注意，调用wait()方法后，会释放对象的锁；
	wait(long)：超时等待一段时间，这里的参数时间是毫秒，也就是等待长达N毫秒，如果没有通知就超市返回；
	wait(long,int)：对于超时时间更细颗粒度的控制，可以达到纳秒级；
	2、线程间的管道输入流和输出流
	PipedOutputStream、Pipe的InputStream、PipedReader、PipedWriter，前两种是面向字节，而后两种是面向字符；
	3、Thread.join()的使用
	如果一个线程A执行了thread.join()方法，则线程A等待thread线程终止之后才从thread.join()方法；还提供了join(long millis)、join(long millis,int nanos)两个具备超时特性的方法，这两个方法表示，如果线程在给定的超时时间里没有终止，则将会超时方法中返回；
	4、ThreadLocal的使用
	ThreadLocal即线程变量，是一个以ThreadLocal对象为键，任意对象为值的存储结构。这个结构被附带在线程上。也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值；可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值；（可以用于值时间的计算）
18、锁
	java实现了很多工具类用于管理线程；
	1、LOCK锁
	2、AbstractQueuedSynchronizer同步器
	3、重入锁（ReentrantLock）
	允许线程重复的获取锁，入用Synchronize修饰的会隐私的支持重复获取锁；
	4、读写锁（java并发包提供了读写锁的实现：ReentrantReadWriteLock，接口：ReadWriteLock）
	读写锁允许同一时刻多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞，读写锁维护了一对锁，一个读锁和一个写锁通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升；
	5、LockSupport工具类
	LockSupport工具类定义了一组公共静态方法，这些方法提供了最基本的线程阻塞和唤醒功能。
	void park()：阻塞当前线程，如果调用unpark(Thread thread)方法或者当前线程被中断，才能冲park()方法返回；
	void parkNanos(long nanos)：阻塞当前线程，最长不超过nanos纳秒，返回条件在park()的基础上增加了超时返回；
	void parkUntil(long deadline)：阻塞当前线程，直到deadline时间（从1970年开始毫秒数）；
	void unpark(Thread thread)：唤醒处于阻塞状态的线程thread；
19、java并发容器及框架
	1、ConcurrentHashMap
	线程安全且高效的HashMap实现；提供了get()、put()等方法
	2、ConcurrentLinkedQueue
	ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，但添加一个元素时候，它会添加到队列尾部；获取一个元素时，会从队列头部返回元素，采用CAS算法实现的非阻塞队列；
20、阻塞队列：
	ArrayBlockingQueue：一个有数组结构组成的有界阻塞队列；（先进先出规则）
	LinkedBlockingQueue：一个有链表结构组成的有界阻塞队列；（最大长度Integer.MAX_VALUE）
	PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列； （自然顺序排序）
	DelayQueue：一个使用优先级队列实现的无界阻塞队列；
	SynchronousQueue：一个不存储元素的阻塞队列；
	LinkedTransferQueue：一个由链表结构组成的无界阻塞队列；
	LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列；
21、Fork/Join框架
	Fork/Join框架是java7提供的一个用于并行执行任务的框架，是一个把大任务切割成若干个小人物，最终汇总每个小任务得到大任务结果的框架；
	java在java.util.concurrent包下提供了forkJoin对应的工具类；
22、java中的13个原子操作类
	在java.util.concurrent.atomic包下的原子操作类提供了一种用法简单、性能高效、线程安全的更新一个变量的方式；
	AtomicBoolean
	AtomicInteger
	AtomicLong
	AtomicIntegerArray
	AtomicLongArray
	AtomicReferenceArray
	AtomicIntegerArray
	等
23、java中的并发工具类
	1、等待线程完成的CountDownLatch
	CountDownLatch允许一个或多个线程等待其他线程完成操作；提供了await方法；
	2、同步屏蔽CyclicBarrier
	3、控制并发线程数的Semaphore
	4、线程间交换数据的Exchanger
24、java中的线程池
	在开发中合理的使用线程池建带来三个好处：
	第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗；
	第二：提高响应速度。但任务到达时，任务可能不需要等到线程创建就能立即执行；
	第三：提高线程的可管理型。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统稳定性，使用线程池可以进行统一的分配、调优和监控。
	1、线程池的实现原理
	1）线程池判断核心线程池里的线程是否都在执行任务，如果不是，则创建一个新的线程来执行任务。如果核心线程池的线程都在执行任务，则进入下一个流程；
	2）线程池判断工作队列是否已经满，则将新提交的任务存储在这个线程队列里。如果工作队列满了，则进入下个流程；
	3）线程池判断线程池的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务；
	2、合理的配置线程池
	如有如下几个角度的分析：
	任务的性质：CPU密集型任务、IO密集型任务和混合型任务；
	任务的优先级：高、中、低；
	任务的执行时间：长、中、短；
	任务的依赖性：是否依赖其他系统资源，如数据库链接；
	性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务应配置尽量小的香橙，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一定在执行任务，则应配置尽可能多的任务，如2*Ncpu。混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没有必要进行分解。
25、Executor框架
	ThreadPoolExecutor（Executor框架最核心的类，是线程池的实现类）通过使用工厂类Executors来创建；其下子类有：
	1）FixedThreadPool：提供了创建可重用固定线程数的线程池；
	2）SingleThreadExecutor：使用单线程执行任务；
	3）CachedThreadPool：提供了无界的可复用线程池；
	4）ScheduledThreadPoolExecutor继承ThreadPoolExecutor，它主要用来给定的延迟之后运行任务，或者定时执行任务。功能与Timer类似；
	Future接口实现类：
	FutureTask：实现了Future接口外还实现了Runnable接口，可提交给Executor执行。异步计算结果；











